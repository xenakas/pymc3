{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Automatic autoencoding variational Bayes for latent dirichlet allocation with PyMC3\n",
    "\n",
    "For probabilistic models with latent variables, autoencoding variational Bayes (AEVB; Kingma and Welling, 2014) is an algorithm which allows us to perform inference efficiently for large datasets with an encoder. In AEVB, the encoder is used to infer variational parameters of approximate posterior on latent variables from given samples. By using tunable and flexible encoders such as multilayer perceptrons (MLPs), AEVB approximates complex variational posterior based on mean-field approximation, which does not utilize analytic representations of the true posterior. Combining AEVB with ADVI (Kucukelbir et al., 2015), we can perform posterior inference on almost arbitrary probabilistic models involving continuous latent variables. \n",
    "\n",
    "I have implemented AEVB for ADVI with mini-batch on PyMC3. To demonstrate flexibility of this approach, we will apply this to latent dirichlet allocation (LDA; Blei et al., 2003) for modeling documents. In the LDA model, each document is assumed to be generated from a multinomial distribution, whose parameters are treated as latent variables. By using AEVB with an MLP as an encoder, we will fit the LDA model to the 20-newsgroups dataset. \n",
    "\n",
    "In this example, extracted topics by AEVB seem to be qualitatively comparable to those with a standard LDA implementation, i.e., online VB implemented on scikit-learn. Unfortunately, the predictive accuracy of unseen words is less than the standard implementation of LDA, it might be due to the mean-field approximation. However, the combination of AEVB and ADVI allows us to quickly apply more complex probabilistic models than LDA to big data with the help of mini-batches. I hope this notebook will attract readers, especially practitioners working on a variety of machine learning tasks, to probabilistic programming and PyMC3. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "env: THEANO_FLAGS=device=cpu,floatX=float64\n"
     ]
    }
   ],
   "source": [
    "%matplotlib inline\n",
    "import sys, os\n",
    "# unfortunately I was not able to run it on GPU due to overflow problems\n",
    "%env THEANO_FLAGS=device=cpu,floatX=float64\n",
    "import theano\n",
    "\n",
    "from collections import OrderedDict\n",
    "from copy import deepcopy\n",
    "import numpy as np\n",
    "from time import time\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer\n",
    "from sklearn.datasets import fetch_20newsgroups\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from theano import shared\n",
    "import theano.tensor as tt\n",
    "from theano.sandbox.rng_mrg import MRG_RandomStreams\n",
    "\n",
    "import pymc3 as pm\n",
    "from pymc3 import math as pmmath\n",
    "from pymc3 import Dirichlet\n",
    "from pymc3.distributions.transforms import t_stick_breaking\n",
    "plt.style.use('seaborn-darkgrid')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Dataset\n",
    "Here, we will use the 20-newsgroups dataset. This dataset can be obtained by using functions of scikit-learn. The below code is partially adopted from an example of scikit-learn (http://scikit-learn.org/stable/auto_examples/applications/topics_extraction_with_nmf_lda.html). We set the number of words in the vocabulary to 1000.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loading dataset...\n",
      "done in 1.181s.\n",
      "Extracting tf features for LDA...\n",
      "done in 1.655s.\n"
     ]
    }
   ],
   "source": [
    "# The number of words in the vocaburary\n",
    "n_words = 1000\n",
    "\n",
    "print(\"Loading dataset...\")\n",
    "t0 = time()\n",
    "dataset = fetch_20newsgroups(shuffle=True, random_state=1,\n",
    "                             remove=('headers', 'footers', 'quotes'))\n",
    "data_samples = dataset.data\n",
    "print(\"done in %0.3fs.\" % (time() - t0))\n",
    "\n",
    "# Use tf (raw term count) features for LDA.\n",
    "print(\"Extracting tf features for LDA...\")\n",
    "tf_vectorizer = CountVectorizer(max_df=0.95, min_df=2, max_features=n_words,\n",
    "                                stop_words='english')\n",
    "\n",
    "t0 = time()\n",
    "tf = tf_vectorizer.fit_transform(data_samples)\n",
    "feature_names = tf_vectorizer.get_feature_names()\n",
    "print(\"done in %0.3fs.\" % (time() - t0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each document is represented by 1000-dimensional term-frequency vector. Let's check the data. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(tf[:10, :].toarray().T);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We split the whole documents into training and test sets. The number of tokens in the training set is 480K. Sparsity of the term-frequency document matrix is 0.025%, which implies almost all components in the term-frequency matrix is zero. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of docs for training = 10000\n",
      "Number of docs for test = 1314\n",
      "Number of tokens in training set = 480263\n",
      "Sparsity = 0.0253936\n"
     ]
    }
   ],
   "source": [
    "n_samples_tr = 10000\n",
    "n_samples_te = tf.shape[0] - n_samples_tr\n",
    "docs_tr = tf[:n_samples_tr, :]\n",
    "docs_te = tf[n_samples_tr:, :]\n",
    "print('Number of docs for training = {}'.format(docs_tr.shape[0]))\n",
    "print('Number of docs for test = {}'.format(docs_te.shape[0]))\n",
    "\n",
    "n_tokens = np.sum(docs_tr[docs_tr.nonzero()])\n",
    "print('Number of tokens in training set = {}'.format(n_tokens))\n",
    "print('Sparsity = {}'.format(\n",
    "    len(docs_tr.nonzero()[0]) / float(docs_tr.shape[0] * docs_tr.shape[1])))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Log-likelihood of documents for LDA\n",
    "For a document $d$ consisting of tokens $w$, the log-likelihood of the LDA model with $K$ topics is given as\n",
    "\\begin{eqnarray}\n",
    "    \\log p\\left(d|\\theta_{d},\\beta\\right) & = & \\sum_{w\\in d}\\log\\left[\\sum_{k=1}^{K}\\exp\\left(\\log\\theta_{d,k} + \\log \\beta_{k,w}\\right)\\right]+const, \n",
    "\\end{eqnarray}\n",
    "where $\\theta_{d}$ is the topic distribution for document $d$ and $\\beta$ is the word distribution for the $K$ topics. We define a function that returns a tensor of the log-likelihood of documents given $\\theta_{d}$ and $\\beta$. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "def logp_lda_doc(beta, theta):\n",
    "    \"\"\"Returns the log-likelihood function for given documents. \n",
    "    \n",
    "    K : number of topics in the model\n",
    "    V : number of words (size of vocabulary)\n",
    "    D : number of documents (in a mini-batch)\n",
    "    \n",
    "    Parameters\n",
    "    ----------\n",
    "    beta : tensor (K x V)\n",
    "        Word distributions. \n",
    "    theta : tensor (D x K)\n",
    "        Topic distributions for documents. \n",
    "    \"\"\"\n",
    "    def ll_docs_f(docs):\n",
    "        dixs, vixs = docs.nonzero()\n",
    "        vfreqs = docs[dixs, vixs]\n",
    "        ll_docs = vfreqs * pmmath.logsumexp(\n",
    "            tt.log(theta[dixs]) + tt.log(beta.T[vixs]), axis=1).ravel()\n",
    "        \n",
    "        # Per-word log-likelihood times num of tokens in the whole dataset\n",
    "        return tt.sum(ll_docs) / (tt.sum(vfreqs)+1e-9) * n_tokens\n",
    "    \n",
    "    return ll_docs_f"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the inner function, the log-likelihood is scaled for mini-batches by the number of tokens in the dataset. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## LDA model\n",
    "With the log-likelihood function, we can construct the probabilistic model for LDA. `doc_t` works as a placeholder to which documents in a mini-batch are set.  \n",
    "\n",
    "For ADVI, each of random variables $\\theta$ and $\\beta$, drawn from Dirichlet distributions, is transformed into unconstrained real coordinate space. To do this, by default, PyMC3 uses a centered stick-breaking transformation. Since these random variables are on a simplex, the dimension of the unconstrained coordinate space is the original dimension minus 1. For example, the dimension of $\\theta_{d}$ is the number of topics (`n_topics`) in the LDA model, thus the transformed space has dimension `(n_topics - 1)`. It shuold be noted that, in this example, we use `t_stick_breaking`, which is a numerically stable version of `stick_breaking` used by default. This is required to work ADVI for the LDA model. \n",
    "\n",
    "The variational posterior on these transformed parameters is represented by a spherical Gaussian distributions (meanfield approximation). Thus, the number of variational parameters of $\\theta_{d}$, the latent variable for each document, is `2 * (n_topics - 1)` for means and standard deviations. \n",
    "\n",
    "In the last line of the below cell, `DensityDist` class is used to define the log-likelihood function of the model. The second argument is a Python function which takes observations (a document matrix in this example) and returns the log-likelihood value. This function is given as a return value of `logp_lda_doc(beta, theta)`, which has been defined above. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_topics = 10\n",
    "# we have sparse dataset. It's better to have dence batch so that all words accure there\n",
    "minibatch_size = 128\n",
    "\n",
    "# defining minibatch\n",
    "doc_t_minibatch = pm.Minibatch(docs_tr.toarray(), minibatch_size)\n",
    "doc_t = shared(docs_tr.toarray()[:minibatch_size])\n",
    "with pm.Model() as model:\n",
    "    theta = Dirichlet('theta', a=pm.floatX((1.0 / n_topics) * np.ones((minibatch_size, n_topics))), \n",
    "                      shape=(minibatch_size, n_topics), transform=t_stick_breaking(1e-9),\n",
    "                      # do not forget scaling\n",
    "                      total_size=n_samples_tr)\n",
    "    beta = Dirichlet('beta', a=pm.floatX((1.0 / n_topics) * np.ones((n_topics, n_words))), \n",
    "                     shape=(n_topics, n_words), transform=t_stick_breaking(1e-9))\n",
    "    # Note, that we devined likelihood with scaling, se here we need no additional `total_size` kwarg\n",
    "    doc = pm.DensityDist('doc', logp_lda_doc(beta, theta), observed=doc_t)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Encoder\n",
    "Given a document, the encoder calculates variational parameters of the (transformed) latent variables, more specifically, parameters of Gaussian distributions in the unconstrained real coordinate space. The `encode()` method is required to output variational means and stds as a tuple, as shown in the following code. As explained above, the number of variational parameters is `2 * (n_topics) - 1`. Specifically, the shape of `zs_mean` (or `zs_std`) in the method is `(minibatch_size, n_topics - 1)`. It should be noted that `zs_std` is defined as $\\rho = log(exp(std) - 1)$ in `ADVI` and bounded to be positive. The inverse parametrization is $std = log(1+exp(\\rho))$ and considered to be numericaly stable.\n",
    "\n",
    "To enhance generalization ability to unseen words, a bernoulli corruption process is applied to the inputted documents. Unfortunately, I have never see any significant improvement with this. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "class LDAEncoder:\n",
    "    \"\"\"Encode (term-frequency) document vectors to variational means and (log-transformed) stds. \n",
    "    \"\"\"\n",
    "    def __init__(self, n_words, n_hidden, n_topics, p_corruption=0, random_seed=1):\n",
    "        rng = np.random.RandomState(random_seed)\n",
    "        self.n_words = n_words\n",
    "        self.n_hidden = n_hidden\n",
    "        self.n_topics = n_topics\n",
    "        self.w0 = shared(0.01 * rng.randn(n_words, n_hidden).ravel(), name='w0')\n",
    "        self.b0 = shared(0.01 * rng.randn(n_hidden), name='b0')\n",
    "        self.w1 = shared(0.01 * rng.randn(n_hidden, 2 * (n_topics - 1)).ravel(), name='w1')\n",
    "        self.b1 = shared(0.01 * rng.randn(2 * (n_topics - 1)), name='b1')\n",
    "        self.rng = MRG_RandomStreams(seed=random_seed)\n",
    "        self.p_corruption = p_corruption\n",
    "    \n",
    "    def encode(self, xs):\n",
    "        if 0 < self.p_corruption:\n",
    "            dixs, vixs = xs.nonzero()\n",
    "            mask = tt.set_subtensor(\n",
    "                tt.zeros_like(xs)[dixs, vixs], \n",
    "                self.rng.binomial(size=dixs.shape, n=1, p=1-self.p_corruption)\n",
    "            )\n",
    "            xs_ = xs * mask\n",
    "        else:\n",
    "            xs_ = xs\n",
    "\n",
    "        w0 = self.w0.reshape((self.n_words, self.n_hidden))\n",
    "        w1 = self.w1.reshape((self.n_hidden, 2 * (self.n_topics - 1)))\n",
    "        hs = tt.tanh(xs_.dot(w0) + self.b0)\n",
    "        zs = hs.dot(w1) + self.b1\n",
    "        zs_mean = zs[:, :(self.n_topics - 1)]\n",
    "        zs_rho = zs[:, (self.n_topics - 1):]\n",
    "        return {'mu': zs_mean, 'rho':zs_rho}\n",
    "        \n",
    "    def get_params(self):\n",
    "        return [self.w0, self.b0, self.w1, self.b1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To feed the output of the encoder to the variational parameters of $\\theta$, we set an OrderedDict of tuples as below.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "OrderedDict([(theta,\n",
       "              {'mu': Subtensor{::, :int64:}.0,\n",
       "               'rho': Subtensor{::, int64::}.0})])"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "encoder = LDAEncoder(n_words=n_words, n_hidden=100, n_topics=n_topics, p_corruption=0.0)\n",
    "local_RVs = OrderedDict([(theta, encoder.encode(doc_t))])\n",
    "local_RVs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`theta` is the random variable defined in the model creation and is a key of an entry of the `OrderedDict`. The value `(encoder.encode(doc_t), n_samples_tr / minibatch_size)` is a tuple of a theano expression and a scalar. The theano expression `encoder.encode(doc_t)` is the output of the encoder given inputs (documents). The scalar `n_samples_tr / minibatch_size` specifies the scaling factor for mini-batches. \n",
    "\n",
    "ADVI optimizes the parameters of the encoder. They are passed to the function for ADVI. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[w0, b0, w1, b1]"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "encoder_params = encoder.get_params()\n",
    "encoder_params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## AEVB with ADVI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Average Loss = 2.9916e+06: 100%|██████████| 10000/10000 [03:31<00:00, 47.30it/s]\n",
      "Finished [100%]: Average Loss = 2.995e+06\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<pymc3.variational.approximations.MeanField at 0x7f6bd4624cc0>"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "η = .1\n",
    "s = shared(η)\n",
    "def reduce_rate(a, h, i):\n",
    "    s.set_value(η/((i/minibatch_size)+1)**.7)\n",
    "\n",
    "with model:\n",
    "    approx = pm.MeanField(local_rv=local_RVs)\n",
    "    approx.scale_cost_to_minibatch = False\n",
    "    inference = pm.KLqp(approx)\n",
    "inference.fit(10000, callbacks=[reduce_rate], obj_optimizer=pm.sgd(learning_rate=s), \n",
    "              more_obj_params=encoder_params, total_grad_norm_constraint=200, \n",
    "              more_replacements={doc_t:doc_t_minibatch})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Approximation{MeanFieldGroup[None, 9] & MeanFieldGroup[9990]}\n"
     ]
    }
   ],
   "source": [
    "print(approx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(approx.hist[10:]);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Extraction of characteristic words of topics based on posterior samples\n",
    "By using estimated variational parameters, we can draw samples from the variational posterior. To do this, we use function `sample_vp()`. Here we use this function to obtain posterior mean of the word-topic distribution $\\beta$ and show top-10 words frequently appeared in the 10 topics. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To apply the above function for the LDA model, we redefine the probabilistic model because the number of documents to be tested changes. Since variational parameters have already been obtained, we can reuse them for sampling from the approximate posterior distribution. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Topic #0: people think god don just know said time say government\n",
      "Topic #1: use key windows drive using file chip scsi like bit\n",
      "Topic #2: just like don year good time car think team game\n",
      "Topic #3: edu space information com available nasa list new ftp mail\n",
      "Topic #4: know thanks does like mail don just help need post\n",
      "Topic #5: ax max g9v b8f pl cx bhj 75u a86 chz\n",
      "Topic #6: just like don new good know think use ve price\n",
      "Topic #7: db just like don cs bh know good think does\n",
      "Topic #8: 00 10 25 15 20 11 16 12 14 50\n",
      "Topic #9: like just don know new good does think use thanks\n"
     ]
    }
   ],
   "source": [
    "def print_top_words(beta, feature_names, n_top_words=10):\n",
    "    for i in range(len(beta)):\n",
    "        print((\"Topic #%d: \" % i) + \" \".join([feature_names[j]\n",
    "            for j in beta[i].argsort()[:-n_top_words - 1:-1]]))\n",
    "\n",
    "\n",
    "doc_t.set_value(docs_tr.toarray())\n",
    "samples = pm.sample_approx(approx, draws=100)\n",
    "beta_pymc3 = samples['beta'].mean(axis=0)\n",
    "\n",
    "print_top_words(beta_pymc3, feature_names)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We compare these topics to those obtained by a standard LDA implementation on scikit-learn, which is based on an online stochastic variational inference (Hoffman et al., 2013). We can see that estimated words in the topics are qualitatively similar. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 9.28 s, sys: 16 ms, total: 9.29 s\n",
      "Wall time: 9.29 s\n",
      "Topic #0: people gun armenian war armenians turkish states said state 000\n",
      "Topic #1: government people law mr president use don think right public\n",
      "Topic #2: space science nasa program data research center output earth launch\n",
      "Topic #3: key car chip used keys bit bike clipper use number\n",
      "Topic #4: edu file com mail available ftp image files information list\n",
      "Topic #5: god people does jesus think believe don say just know\n",
      "Topic #6: windows drive use thanks does card know problem like db\n",
      "Topic #7: ax max g9v pl b8f a86 cx 34u 145 1t\n",
      "Topic #8: just don like know think good time ve people year\n",
      "Topic #9: 00 10 25 15 20 12 11 16 14 17\n"
     ]
    }
   ],
   "source": [
    "from sklearn.decomposition import LatentDirichletAllocation\n",
    "\n",
    "lda = LatentDirichletAllocation(n_topics=n_topics, max_iter=5,\n",
    "                                learning_method='online', learning_offset=50.,\n",
    "                                random_state=0)\n",
    "%time lda.fit(docs_tr)\n",
    "beta_sklearn = lda.components_ / lda.components_.sum(axis=1)[:, np.newaxis]\n",
    "\n",
    "print_top_words(beta_sklearn, feature_names)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Predictive distribution\n",
    "In some papers (e.g., Hoffman et al. 2013), the predictive distribution of held-out words was proposed as a quantitative measure for goodness of the model fitness. The log-likelihood function for tokens of the held-out word can be calculated with posterior means of $\\theta$ and $\\beta$. The validity of this is explained in (Hoffman et al. 2013). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calc_pp(ws, thetas, beta, wix):\n",
    "    \"\"\"\n",
    "    Parameters\n",
    "    ----------\n",
    "    ws: ndarray (N,)\n",
    "        Number of times the held-out word appeared in N documents. \n",
    "    thetas: ndarray, shape=(N, K)\n",
    "        Topic distributions for N documents.         \n",
    "    beta: ndarray, shape=(K, V)\n",
    "        Word distributions for K topics. \n",
    "    wix: int\n",
    "        Index of the held-out word\n",
    "        \n",
    "    Return\n",
    "    ------\n",
    "    Log probability of held-out words.\n",
    "    \"\"\"\n",
    "    return ws * np.log(thetas.dot(beta[:, wix]))\n",
    "\n",
    "def eval_lda(transform, beta, docs_te, wixs):\n",
    "    \"\"\"Evaluate LDA model by log predictive probability. \n",
    "    \n",
    "    Parameters\n",
    "    ----------\n",
    "    transform: Python function\n",
    "        Transform document vectors to posterior mean of topic proportions. \n",
    "    wixs: iterable of int\n",
    "        Word indices to be held-out. \n",
    "    \"\"\"\n",
    "    lpss = []\n",
    "    docs_ = deepcopy(docs_te)\n",
    "    thetass = []\n",
    "    wss = []\n",
    "    total_words = 0\n",
    "    for wix in wixs:\n",
    "        ws = docs_te[:, wix].ravel()\n",
    "        if 0 < ws.sum():\n",
    "            # Hold-out\n",
    "            docs_[:, wix] = 0\n",
    "            \n",
    "            # Topic distributions\n",
    "            thetas = transform(docs_)\n",
    "        \n",
    "            # Predictive log probability\n",
    "            lpss.append(calc_pp(ws, thetas, beta, wix))\n",
    "            \n",
    "            docs_[:, wix] = ws\n",
    "            thetass.append(thetas)\n",
    "            wss.append(ws)\n",
    "            total_words += ws.sum()\n",
    "        else:\n",
    "            thetass.append(None)\n",
    "            wss.append(None)\n",
    "    \n",
    "    # Log-probability\n",
    "    lp = np.sum(np.hstack(lpss)) / total_words\n",
    "    \n",
    "    return {\n",
    "        'lp': lp, \n",
    "        'thetass': thetass, \n",
    "        'beta': beta, \n",
    "        'wss': wss\n",
    "    }"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`transform()` function is defined with `sample_vp()` function. This function is an argument to the function for calculating log predictive probabilities. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "inp = tt.matrix(dtype='int64')\n",
    "sample_vi_theta = theano.function(\n",
    "    [inp],\n",
    "    approx.sample_node(approx.model.theta, 100,  more_replacements={doc_t: inp}).mean(0)\n",
    ")\n",
    "def transform_pymc3(docs):\n",
    "    return sample_vi_theta(docs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 43.4 s, sys: 1min 12s, total: 1min 55s\n",
      "Wall time: 18.9 s\n",
      "Predictive log prob (pm3) = -6.157971529305059\n"
     ]
    }
   ],
   "source": [
    "%time result_pymc3 = eval_lda(transform_pymc3, beta_pymc3, docs_te.toarray(), np.arange(100))\n",
    "print('Predictive log prob (pm3) = {}'.format(result_pymc3['lp']))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We compare the result with the scikit-learn LDA implemented The log predictive probability is comparable (-6.24) with AEVB-ADVI, and it shows good set of words in the estimated topics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 34.6 s, sys: 34.4 s, total: 1min 9s\n",
      "Wall time: 23.7 s\n",
      "Predictive log prob (sklearn) = -6.014771065227894\n"
     ]
    }
   ],
   "source": [
    "def transform_sklearn(docs):\n",
    "    thetas = lda.transform(docs)\n",
    "    return thetas / thetas.sum(axis=1)[:, np.newaxis]\n",
    "\n",
    "%time result_sklearn = eval_lda(transform_sklearn, beta_sklearn, docs_te.toarray(), np.arange(100))\n",
    "print('Predictive log prob (sklearn) = {}'.format(result_sklearn['lp']))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Summary\n",
    "We have seen that PyMC3 allows us to estimate random variables of LDA, a probabilistic model with latent variables, based on automatic variational inference. Variational parameters of the local latent variables in the probabilistic model are encoded from observations. The parameters of the encoding model, MLP in this example, are optimized with variational parameters of the global latent variables. Once the probabilistic and the encoding models are defined, parameter optimization is done just by invoking an inference (`ADVI()`) without need to derive complex update equations. \n",
    "\n",
    "This notebook shows that even mean field approximation can perform as well as sklearn implementation, which is based on the conjugate priors and thus not relying on the mean field approximation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "## References\n",
    "* Kingma, D. P., & Welling, M. (2014). Auto-Encoding Variational Bayes. stat, 1050, 1.\n",
    "* Kucukelbir, A., Ranganath, R., Gelman, A., & Blei, D. (2015). Automatic variational inference in Stan. In Advances in neural information processing systems (pp. 568-576).\n",
    "* Blei, D. M., Ng, A. Y., & Jordan, M. I. (2003). Latent dirichlet allocation. Journal of machine Learning research, 3(Jan), 993-1022.\n",
    "* Hoffman, M. D., Blei, D. M., Wang, C., & Paisley, J. W. (2013). Stochastic variational inference. Journal of Machine Learning Research, 14(1), 1303-1347.\n",
    "* Rezende, D. J., & Mohamed, S. (2015). Variational inference with normalizing flows. arXiv preprint arXiv:1505.05770.\n",
    "* Salimans, T., Kingma, D. P., & Welling, M. (2015). Markov chain Monte Carlo and variational inference: Bridging the gap. In International Conference on Machine Learning (pp. 1218-1226)."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.2"
  },
  "latex_envs": {
   "bibliofile": "biblio.bib",
   "cite_by": "apalike",
   "current_citInitial": 1,
   "eqLabelWithNumbers": true,
   "eqNumInitial": 0
  },
  "nav_menu": {},
  "toc": {
   "navigate_menu": true,
   "number_sections": true,
   "sideBar": true,
   "threshold": 6,
   "toc_cell": false,
   "toc_section_display": "block",
   "toc_window_display": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
